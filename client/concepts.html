<template name="concepts">

<h1 id="concepts">개념</h1>

우리는 충분히 많은 단일 페이지 JavaScript 애플리케이션을 직접 개발하였다. 
전체 애플리케이션을 단일 데이터 포맷(JSON)을 가진 단일 언어(JavaScript)로 작성한다는 것은 정말 즐겁다. 
미티어에는 이런 앱을 작성하는데 있어 우리가 원하는 모든 것이 들어있다.

{{> whatismeteor }}
{{> structure }}
{{> data_ }}
{{> reactivity }}
{{> livehtmltemplates }}
{{> packages_concept }}
{{> namespacing }}
{{> deploying }}
{{> packages_writing }}
</template>

<template name="whatismeteor">

{{#markdown}}

<h2 id="whatismeteor">미티어란 무엇인가?</h2>

미티어는 두 가지이다:

* _패키지 라이브러리_: 앱에서 필요로 하는 미리 작성된, 독립된 모듈들.<br>
대부분의 앱에서 사용하는 (예를 들면, `webapp`는 인바운드 HTTP connection을 다루고, `templating`으로 데이터 변경시에 자동적으로 변경되는 HTML 템플릿을 만든다) 십 수개의 core 미티어 패키지가 있다. 그리고 옵션 패키지가 있는데, 여기에는 애플리케이션에서 메일을 보낼 수 있는 email, 또는 애플리케이션에 그냥 넣기만 하면 되는 모든 기능을 갖춘 사용자 계정 시스템인 Meteor Accounts 시리즈(`account-password`, `accounts-facebook`, `accounts-ui`, 등)와 같은 것들이 있다. 그리고 이 "공식" 패키지 외에 커뮤니티의 구성원들이 작성한 수 많은 패키지들이 있는 [Atmosphere](https://atmospherejs.com/)가 있는데 이 중에 바로 여러분이 찾는 바로 그것이 있을 수 있다.


* `meteor`라는 이름의 _command-line 도구l_.<br>
`meteor`는 빌드도구로 `make`, `rake`, 또는 비주얼스튜디오의 non-visual 파트와 유사하다. 
이것은 애플리케이션의 모든 소스파일과 자원을 모아서, 
필요한 빌드 단계([CoffeeScript](http://coffeescript.org)를 컴파일하거나, 
CSS를 최적화하거나, [npm](https://npmjs.org/) 모듈을 빌드하거나, 
또는 소스 맵을 생성하는 것과 같은)를 수행하고, 애플리케이션에서 사용되는 패키지를 가져와서, 
독자적으로 실행가능한 상태의 애플리케이션 번들로 출력한다. 개발 모드에서 이 과정 모두가 
반응형으로 동작해서, 어떤 파일을 수정하면 즉시 브라우저에서 그 변경효과를 볼 수 있다. 
이것은 생각보다 훨씬 쉬우면서도 또한 확장가능하기도 하다: 
애플리케이션에 빌드 플러그인 패키지를 추가하면 새로운 언어와 컴파일러에 대한 지원을 추가할 수 있다.

미티어 패키지 시스템의 핵심 아이디어는 _모든 것이 브라우저와 서버에서 동일하게 작동해야 한다_는 것이다
(물론 의미있는 경우에 한해서 말이다: 브라우저는 메일을 보낼 수 없고, 서버는 마우스 이벤트를 가로챌 수 없다). 
우리의 에코시스템은 이를 지원하기 위해서 바닥에서부터 작성되었다.

{{/markdown}}
</template>

<template name="structure">
{{#markdown}}

<h2 id="structuringyourapp">애플리케이션 구성하기</h2>

미티어 애플리케이션은 클라이언트 웹 브라우저 내부에서 실행되는 JavaScript, 
미티어 서버의 [Node.js](http://nodejs.org/) 컨테이너 내부에서 실행되는 JavaScript, 
그리고 모든 HTML 요소들, CSS 규칙, 그리고 정적 자원의 모음이다. 
미티어는 이 다양한 구성요소들의 패키징과 전송을 자동화한다. 
그리고 이 요소들을 애플리케이션의 파일 구조로 구성하는 방법에 있어 아주 유연하다.

유일한 서버 자원은 `private` 서브디렉토리에 있는 JavaScript와 파일들이다. 
미티어는 모든 JavaScript 파일들을 모으되 `client`, `public`, 
그리고 `private` 서브디렉토리에 있는 것은 제외한 다음 fiber 내부에서 Node.js 서버 인스턴스로 로드한다. 
미티어에서, 서버 코드는 Node의 전형적인 비동기 콜백 스타일이 아닌 request 단위의 단일 쓰레드 상태로 실행된다. 
이러한 선형 실행 모델이 미티어 애플리케이션의 전형적인 서버 코드에 더 적합하다.

미티어는 `private` 서브디렉토리의 모든 파일들을 모아서 이 파일들의 콘텐츠를 
[`Assets`](#assets) API를 통해서 서버 코드에서 이용할 수 있게 한다. 
이 `private` 서브디렉토리는 비공개 데이터 파일같은, 서버 코드에는 제공되지만 
클라이언트에는 제공되지 않는 파일들을 위한 장소이다.

클라이언트에서 고려해야 할 더 많은 자원들이 있다. 미티어는 `server`, `public`, 
그리고 `private` 서브디렉토리에 있는 파일들을 제외한 모든 JavaScript 파일들을 클라이언트용으로 모은다. 
그리고 이들을 최소화(minify)하여 번들 형태로 각 클라이언트에 보낸다. 여러분은 애플리케이션 전체를 
하나의 JavaScript 파일에 작성할 수도 있고 여러 파일로 나누어 다층 디렉토리의 트리 형태로 만들 수도 있다.

일부 JavaScript 라이브러리는 `client/compatibility` 서브디렉토리에 있을 때에 한하여 작동한다. 
이 디렉토리에 있는 파일들은 새로운 변수 영역(variable scope)으로 감싸지 않은 상태로 실행된다. 
이것은 각 파일의 상단의 `var`은 전역변수를 정의한다는 것을 의미한다. 
추가로 이 파일들은 다른 클라이언트 영역의 JavaScript 파일들보다 먼저 실행된다.

`client`, `server` 그리고 `tests` 서브디렉토리에 있지 않은 파일들은 클라이언트와 
서버 양쪽에서 로드된다! 여기는 모델 정의와 기타 다른 기능을 처리하는 파일들이 자리하는 곳이다. 
미티어가 제공하는 변수 [`isClient`](#meteor_isclient)와 [`isServer`](#meteor_isserver)를 
이용하면 코드가 클라이언트나 또는 서버에서 실행될 지에 대한 선택을 할 수 있다. 
(`tests` 디렉토리에 있는 파일들은 어느 쪽에도 로드되지 않는다.)

비밀번호를 담을 코드나 인증 메카니즘과 같은, 클라이언트에 제공되면 안되는 민감한 코드들은 
`server` 디렉토리에 있어야 한다.

CSS 파일들도 함께 모아진다: 클라이언트가 (`server`, `public`, 그리고 `private` 서브디렉토리는 
제외하고) 파일 트리에 있는 모든 CSS를 모아서 번들로 만든다.

개발 모드에서는 디버깅을 보다 쉽게 하도록 JavaScript, CSS 파일들을 합치지 않고 개별적으로 보낸다.

미티어 앱에서 HTML 파일들은 서버 기반의 프레임워크에서와는 아주 약간 다른 방식으로 처리된다. 
미티어는 디렉토리에 있는 모든 HTML 파일들을 읽어 3개의 엘리먼트를 찾는다: `<head>`, `<body>`, 
그리고 `<template>`. 이 때, head와 body 섹션은 각각 단일의 head와 body로 합쳐지고 클라이언트 쪽으로 
처음 페이지를 로드할 때 전송된다.

한편, Template 섹션은 JavaScript 함수로 변환되어 `Template` 네임스페이스 아래서 
이용가능한 상태가 된다. 이것은 HTML 템플릿을 클라이언트로 보내는 정말 편리한 방식이다. 
자세한 내용은 [templates](#livehtmltemplates) 섹션을 참조하라.

마지막으로, 미티어 서버는 `public` 디렉토리의 모든 파일들을 처리한다. 이 디렉토리는 이미지 파일, 
favicon.ico, robots.txt, 그리고 기타 다른 파일들이 자리하는 곳이다.

애플리케이션을 작성함에 있어 파일들이 로드되는 순서에 민감하지 않게 작성하는 것이 최선이다. 
예를 들면 [Meteor.startup](#meteor_startup)을 사용하거나, 혹은 로드 순서에 민감한 코드를 
파일의 로드 순서와 다른 패키지에 상대적인 로드 순서를 모두 명시적으로 제어할 수 있는 
[packages](#usingpackages)로 옮기는 방식이 있다. 
그런데 때로는 로드 순서에 의존할 수 밖에 없는 경우가 있다. 
애플리케이션에서 JavaScript와 CSS파일들은 다음의 규칙에 따라서 로드된다:


* 서브디렉토리에 있는 파일들은 그 상위 디렉토리에 있는 파일들보다 먼저 로드된다. 그래서 가장 하위의 서브디렉토리에 있는 파일들이 가장 먼저 로드된다. 그리고 루트 디렉토리에 있는 파일들이 가장 나중에 로드된다.

* 디렉토리 내부에서 파일들은 파일명의 알파벳 순서에 따라서 로드된다.

* 위에서 기술된 내용에 따라서 정렬된 후, `lib`라는 이름을 가진 디렉토리들에 있는 파일들이 (그 순서를 유지하면서) 그 밖의 다른 파일들보다 앞 순서로 이동한다.

* 마지막으로 `main.*`와 일치하는 파일들이 (그 순서를 유지하면서) 그 밖의 모든 파일들의 뒤에 자리한다.

{{/markdown}}
</template>

<template name="data_">
{{#markdown}}

<h2 id="dataandsecurity">데이터와 보안</h2>

미티어에서 분산된 클라이언트 코드를 작성하는 것은 로컬 데이터베이스 작업을 하는 것처럼 간편하다. 
이것은 깔끔하고 단순하며 안전한 접근법으로서, 개별 RPC 엔드포인트들을 구축하고, 
서버와의 느린 통신을 피하기 위해서 클라이언트에 데이터를 수동으로 캐시하고, 
그리고 데이터의 변경시에 모든 클라이언트에 무효화 메시지를 조심스럽게 조정하는 등의 작업을 
하지 않아도 되게 한다.

미티어에서 클라이언트와 서버는 동일한 데이터베이스 API를 공유한다. 똑같은 애플리케이션 
코드 — 유효성 검사 모듈과 계산된 속성들 같은 — 가 종종 양쪽에서 실행될 수 있다. 
그러나 서버에서 실행되는 코드가 데이터베이스에 직접 접속하는 반면, 
클라이언트에서 실행되는 코드는 *그렇지 않다*. 이 차이가 미티어의 데이터 보안 모델의 기반이다.

{{#note}}
새 미티어 앱의 초기 설정상태는 `autopublish`와 `insecure` 패키지를 포함하고 있다. 
이 두 패키지는 각 클라이언트에게 서버의 데이터베이스에 전체 쓰기/읽기 접근 권한을 주는 효과를 낸다. 
이들은 프로토타이핑 도구로서는 유용하지만 실 제품용 애플리케이션에는 적합하지 않다. 
준비가 되면 이 패키지들을 제거하라.
{{/note}}

모든 미티어 클라이언트에는 인메모리 데이터베이스 캐시가 있다. 이 클라이언트 캐시를 다루기 위해서 
서버는 JSON 도큐먼트 집합을 *발행(publish)한다*. 그리고 클라이언트는 이 집합을 *구독(subscribe)한다*. 
이 집합에 있는 도큐먼트들이 변경되면 서버는 각 클라이언트의 캐시를 수정한다.

오늘날 대부분의 미티어 앱은 MongoDB를 데이터베이스로 사용하는데 이는 가장 잘 지원되기 때문이며, 
다른 데이터베이스는 가까운 미래에 지원될 것이다.  [`Meteor.Collection`](http://docs.meteor.com/#meteor_collection) 클래스는 Mongo collection을 선언하고 이를 조작하는 데 사용된다. 미티어의 클라이언트에서 사용되는 Mongo 에뮬레이터인 `minimongo` 덕분에 `Meteor.Collection`은 클라이언트와 서버 양쪽에서 모두 사용될 수 있다.

    // declare collections
    // this code should be included in both the client and the server
    Rooms = new Meteor.Collection("rooms");
    Messages = new Meteor.Collection("messages");
    Parties = new Meteor.Collection("parties");

    // server: populate collections with some initial documents
    Rooms.insert({name: "Conference Room A"});
    var myRooms = Rooms.find({}).fetch();
    Messages.insert({text: "Hello world", room: myRooms[0]._id});
    Parties.insert({name: "Super Bowl Party"});

각 도큐먼트 집합은 서버에서 publish 함수로 정의한다. 이 publish 함수는 새로운 클라이언트가 
도큐먼트 집합을 구독(subscribe)하는 시점마다 실행된다. 도큐먼트 집합의 데이터는 
어떤 방식으로 만들어 질 수도 있지만, 기장 일반적인 방식은 데이터베이스 쿼리를 발행(publish)하는 
방식으로 만들어진다.

    // server: publish all room documents
    Meteor.publish("all-rooms", function () {
      return Rooms.find(); // everything
    });

    // server: publish all messages for a given room
    Meteor.publish("messages", function (roomId) {
      check(roomId, String);
      return Messages.find({room: roomId});
    });

    // server: publish the set of parties the logged-in user can see.
    Meteor.publish("parties", function () {
      return Parties.find({$or: [{"public": true},
                                 {invited: this.userId},
                                 {owner: this.userId}]});
    });

발행(publish) 함수는 각 클라이언트마다 다른 결과를 제공할 수도 있다. 마지막 예를 보면, 
로그인 사용자는 전체 `Party` 도큐먼트들 중에서 공개적이거나, 해당 사용자 소유이거나, 
초대자 명단에 있는 사용자인 도큐먼트들만 볼 수 있다.

일단 구독(subscribe)을 하면, 클라이언트는 그 캐시를 빠른 로컬 데이터베이스처럼 사용할 수 있어, 
클라이언트 코드를 극적으로 단축한다. Read 요청은 서버에 갔다오는 작업을 요구하지 않는다. 
그리고 이 요청은 캐시에 있는 콘텐츠에 한정된다: 클라이언트에서 collection에 대한 모든 도큐먼트의 
쿼리는 서버가 클라이언트에 발행한 도큐먼트만을 리턴한다.

    // client: start a parties subscription
    Meteor.subscribe("parties");

    // client: return array of Parties this client can read
    return Parties.find().fetch(); // synchronous!

수준높은 클라이언트라면 캐시에 저장되는 데이터 크기를 제어하고 
네트워크 트래픽을 관리하기 위해서 구독을 껐다 켰다 할 수 있다. 
구독이 꺼지면 활성화된 또 다른 구독이 없다면 모든 도큐먼트가 캐시에서 제거된다.

클라이언트가 하나 이상의 도큐먼트를 *수정하면*, 미티어는 서버에게 변경 요청 메시지를 보낸다. 
서버는 요청을 받아서 여러분이 JavaScript 함수로 작성한 allow/deny 규정에 의거하여 검사한다.
서버는 이 모든 규정을 통과한 변경 요청만을 받아들인다.


    // server: don't allow client to insert a party
    Parties.allow({
      insert: function (userId, party) {
        return false;
      }
    });

    // client: this will fail
    var party = { ... };
    Parties.insert(party);

서버가 그 변경요청을 수용하면, 데이터베이스에 그 변경내용을 반영하고 연관된 도큐먼트들을 구독하는 
모든 클라이언트들에게 그 변경내용을 자동으로 전파한다. 서버가 수용하지 않으면, 변경은 실패하고, 
서버의 데이터베이스는 그대로 남아있고 다른 클라이언트들은 그 변경과정을 알지 못한다.

미티어에는 영리한 재주가 또 있다. 클라이언트가 서버에 변경 요청을 보낼 때, 
서버로부터의 반응을 기다리지 않고, 로컬 캐시를 즉시 변경한다. 
이는 화면이 바로 다시 그려진다는 것을 의미한다. 
만약 서버가 그 변경 — 정상적인 클라이언트에서 대부분의 경우 당연히 진행될 변경 — 을 수용했다면 
클라이언트는 화면을 변경하기 위해서 서버에 갔다오는 시간을 기다릴 필요가 없는 것이다. 
만약 서버가 그 변경을 거절하면, 미티어는 서버의 그 리턴 결과를 클라이언트의 캐시에 반영한다.

이 과정 전체를 합친 기술이 대기시간 보정(latency compensation)이다. 클라이언트는 
필요한 데이터의 복제본을 가지고 있어, 서버에 다녀오는 시간을 기다릴 필요가 없다. 그리고 
클라이언트가 데이터를 수정할 때, 그 수정 작업은 서버로부터의 확인을 기다리지 않고 
로컬에서 실행될 수 있다. 그리고 서버에게는 요청한 변경에 대한 답변의 기회를 주고 있다.


{{#note}}
미티어의 현재 버전은 유명한 도큐먼트 기반의 데이터베이스인 MongoDB를 지원한다. 
그리고 이 섹션의 예제는 [MongoDB API](http://www.mongodb.org/display/DOCS/Manual)를 이용한다. 
미래 버전에서는 다른 데이터베이스에 대한 지원이 포함될 것이다.
{{/note}}

<h3 id="dataandsecurity-authentication">인증과 사용자 계정</h3>

미티어에는 Meteor Accounts가 들어있는데, 이는 최신의 인증 시스템이다. 
이것은 [bcrypt](http://en.wikipedia.org/wiki/Bcrypt) 알고리즘을 이용한 암호화된 비밀번호 로그인 기능과 
페이스북, 깃허브, 구글, 밋업, 트위터, 그리고 웨이보를 포함하는 외부 서비스와의 연동기능을 특징으로 한다. 
Meteor Accounts는 개발자가 추가 사용자 정보를 저장할 수 있는 [`Meteor.users`](#meteor_users) 컬렉션을 정의한다.

미티어는 또한 로그인, 회원가입, 비밀번호 변경, 비밀번호 리셋 메일과 같은 공통의 기능을 위한 빌트인 폼을 포함하고 있다. 
단 한 줄의 코드로 앱에 [Accounts UI](#accountsui)를 추가할 수 있다. `accounts-ui` 패키지는 
설정 마법사도 제공하여 앱에서 사용할 외부 로그인 서비스 설정을 단계별로 할 수 있도록 하고 있다.

<h3 id="dataandsecurity-validation">입력 유효성 검사</h3>

미티어에서는 직접 작성하는 메서드와 발행 함수가 어떤 [JSON](http://json.org/) 형식의 매개변수라도 수용한다. 
(사실, 미티어의 접속 프로토콜은 EJSON을 지원하는데 이는 날짜, 이진 버퍼같은 다른 일반적인 형식도 지원한다.) 
JavaScript의 동적 타이핑은 앱에서 모든 변수의 형식을 정확하게 지정하지 않아도 된다는 것을 의미하지만, 
클라이언트가 메서드와 발행 함수에 전달하는 매개변수가 원하는 형식이라는 것을 확실하게 해 두는 것이 바람직하다.

미티어는 매개변수와 기타 값들이 원래 기대했던 형식인지를 검사하는 [경량 라이브러리](#match)를 제공한다. 
단순히 함수를 정의할 때, `check(username, String)`나 `check(office, {building: String, room: Number})`와 같은 
문장으로 시작하라. 이 `check' 호출은 매개변수가 기대했던 형식이 아니면 오류를 발생시킬 것이다.

미티어는 또한 모든 메서드와 발행 함수들이 그 매개변수의 유효성을 검사하는 쉬운 방법을 제공한다. 
그저 <code>meteor add [audit-argument-checks](#auditargumentchecks)</code>를 실행하면 
어떤 메서드나 발행 함수가 매개변수에 대하여 `check` 함수 적용을 빠트렸을 때 예외를 발생시키면서 오류를 낼 것이다.

{{/markdown}}
</template>

<template name="reactivity">
{{#markdown}}

<h2 id="reactivity">반응성(Reactivity)</h2>

미티어는 [반응형 프로그래밍](http://en.wikipedia.org/wiki/Reactive_programming)의 개념을 담고 있다. 
이 의미는 단순 명령형 프로그래밍 스타일로 코드를 작성하여도, 그 결과는 그 코드와 연관된 데이터가 변경될 때마다 
자동으로 재계산된다는 것을 의미한다.

    Tracker.autorun(function () {
      Meteor.subscribe("messages", Session.get("currentRoomId"));
    });

(채팅방 클라이언트에서 추출된) 이 예제는 세션변수 `currentRoomId`에 따라서 데이터 구독을 설정한다. 
어떤 이유로 `Session.get("currentRoomId")`의 값이 변경되면 이 함수는 자동으로 재실행되어 
이전 값을 대체하는 새로운 구독을 설정한다.

이런 자동 재계산은 `Session`와 `Tracker.autorun` 사이의 협동 작업으로 이루어진다. 
`Tracker.autorun`은 데이터 의존성이 연관된 것 내부에서 임의의 "반응형 계산"을 수행한다. 
그리고 필요한 경우 그 함수의 매개변수를 재실행한다. 한편, `Session`과 같이 데이터를 제공하는 쪽은 
그들을 호출하는 대상과 어떤 데이터가 요청되는 지를 주목하고 있다가 
데이터가 변경될 때 계산하는 쪽으로 무효화 신호를 보낼 준비를 한다.

이런 단순 패턴(반응형 계산 + 반응형 데이터 소스)은 폭넓게 적용되고 있다. 위에서 프로그래머는 
unsubscribe/resubscribe 호출을 작성하지 않아도 되고 이들이 적시에 호출되는 지를 확인할 필요도 없다. 
일반적으로, 미티어는 오류를 내기 쉬운 로직으로 애플리케이션을 버벅이게 할 지도 모르는 
데이터 전파 코드의 모든 클래스를 제거할 수 있다.

이 미티어 함수들은 작성한 코드를 반응형 계산으로 실행한다:

* [Templates](#livehtmltemplates)
* [`Tracker.autorun`](#tracker_autorun)
* [`Blaze.render`](#blaze_render)와 [`Blaze.renderWithData`](#blaze_renderwithdata)

그리고 변경되어 자동 재실행을 유발하는 반응형 데이터 소스들은 다음과 같다:

* [`Session`](#session) 변수
* [Collections](#find)에 대한 데이터베이스 쿼리
* [`Meteor.status`](#meteor_status)
* [subscription handle](#meteor_subscribe)에서의 `ready()` 메서드
* [`Meteor.user`](#meteor_user)
* [`Meteor.userId`](#meteor_userid)
* [`Meteor.loggingIn`](#meteor_loggingin)

추가로, `stop` 메서드를 가진 객체를 리턴하는 다음의 함수들은, 반응형 계산에서 호출되는 경우, 
그 계산이 재실행되거나 중단될 때, 중단된다:

* [`Tracker.autorun`](#tracker_autorun) (nested)
* [`Meteor.subscribe`](#meteor_subscribe)
* 커서에서의 [`observe()`](#observe)와 [`observeChanges()`](#observe_changes)

미티어에서는 [`Tracker`](#tracker)라는 이름의 package로 [구현](https://github.com/meteor/meteor/blob/master/packages/tracker/tracker.js)하였는데 이는 매우 짧고 간결하다. 이를 사용하여 직접 새로운 반응형 데이터 소스를 구축할 수도 있다.

{{/markdown}}
</template>

<template name="livehtmltemplates">
{{#markdown}}

<h2 id="livehtmltemplates">Live HTML templates</h2>

HTML templating is central to web applications. With Blaze, Meteor's live
page update technology, you can render your HTML _reactively_, meaning
that it will update automatically to track changes in the data used to
generate it.

Meteor makes it easy to use your favorite HTML templating language along with
Meteor's live page update technology. Just write your template as you normally
would, and Meteor will take care of making it update in realtime.

Meteor ships with a templating language called
[Spacebars](https://github.com/meteor/meteor/blob/devel/packages/spacebars/README.md),
inspired by [Handlebars](http://handlebarsjs.com/).  It shares some of the
spirit and syntax of Handlebars, but it has been tailored to produce reactive
Meteor templates when compiled.

{{#note}}
  Today, the only templating system that ships with Meteor is Spacebars, though
  our community has created packages for other languages such as
  [Jade](https://atmospherejs.com/package/jade).
{{/note}}

To define templates, create a file in your project with the `.html`
extension. In the file, make a `<template>` tag and give it a
`name` attribute. Put the template contents inside the tag. Meteor
will precompile the template, ship it down to the client, and make it
available as on the global `Template` object.

When your app is loaded, it automatically renders the special template called
`<body>`, which is written using the `<body>` element instead of a
`<template>`. You insert a template inside another template by using the
`{{dstache}}> inclusion}}` operator.

The easiest way to get data into templates is by defining helper
functions in JavaScript. Just add the helper functions directly on the
`Template.`*templateName* object. Putting it all together:


    <!-- in myapp.html -->
    <body>
      <h1>Today's weather!</h1>
      {{dstache}}> forecast}}
    </body>

    <template name="forecast">
      <div>It'll be {{dstache}}prediction}} tonight</div>
    {{lt}}/template>

    // in client/myapp.js: reactive helper function
    Template.forecast.prediction = function () {
      return Session.get("weather");
    };

    // in the JavaScript console
    > Session.set("weather", "cloudy");
    > document.body.innerHTML
     => "<h1>Today's weather!</h1> <div>It'll be cloudy tonight</div>"

    > Session.set("weather", "cool and dry");
    > document.body.innerHTML
     => "<h1>Today's weather!</h1> <div>It'll be cool and dry tonight</div>"


To iterate over an array or database cursor, use `{{dstache}}#each}}`:

    <!-- in myapp.html -->
    <template name="players">
      {{dstache}}#each topScorers}}
        <div>{{dstache}}name}}</div>
      {{dstache}}/each}}
    {{lt}}/template>

    // in myapp.js
    Template.players.topScorers = function () {
      return Users.find({score: {$gt: 100}}, {sort: {score: -1}});
    };

In this case, the data is coming from a database query. When the
database cursor is passed to `{{dstache}}#each}}`, it will wire up all of the
machinery to efficiently add and move DOM nodes as new results enter
the query.

Helpers can take arguments, and they receive the current template context data
in `this`. Note that some block helpers change the current context (notably
`{{dstache}}#each}}` and `{{dstache}}#with}}`):

    // in a JavaScript file
    Template.players.leagueIs = function (league) {
      return this.league === league;
    };

    <!-- in a HTML file -->
    <template name="players">
      {{dstache}}#each topScorers}}
        {{dstache}}#if leagueIs "junior"}}
          <div>Junior: {{dstache}}name}}</div>
        {{dstache}}/if}}
        {{dstache}}#if leagueIs "senior"}}
          <div>Senior: {{dstache}}name}}</div>
        {{dstache}}/if}}
      {{dstache}}/each}}
    {{lt}}/template>

Helpers can also be used to pass in constant data.

    // Works fine with {{dstache}}#each sections}}
    Template.report.sections = ["Situation", "Complication", "Resolution"];

Finally, you can use an `events` declaration on a template function to set up a
table of event handlers. The format is documented at [Event
Maps](#eventmaps). The `this` argument to the event handler will be
the data context of the element that triggered the event.

    <!-- myapp.html -->
    <template name="scores">
      {{dstache}}#each player}}
        {{dstache}}> playerScore}}
      {{dstache}}/each}}
    {{lt}}/template>

    <template name="playerScore">
      <div>{{dstache}}name}}: {{dstache}}score}}
        <span class="givePoints">Give points</span>
      </div>
    {{lt}}/template>

    <!-- myapp.js -->
    Template.playerScore.events({
      'click .givePoints': function () {
        Users.update(this._id, {$inc: {score: 2}});
      }
    });

For more details about Spacebars, read [the Spacebars
README](https://github.com/meteor/meteor/blob/devel/packages/spacebars/README.md).

{{/markdown}}
</template>

<template name="packages_concept">
{{#markdown}}

  <h2 id="usingpackages">Using packages</h2>

All of the functionality you've read about so far is implemented as
standard Meteor packages. This is possible thanks to Meteor's
unusually powerful package and build system. The same packages work in
the browser and on the server, and packages can contain plugins that
extend the build process, such as `coffeescript` ([CoffeeScript](http://coffeescript.org)
compilation) or `templating` (compiling HTML templates).

Anyone can publish a Meteor package, and thousands of community-written packages
have been published to date. The easiest way to browse these packages
is <a href="http://www.atmospherejs.com">Atmosphere</a>, by Percolate Studio. You can
also use [`meteor search`](#meteorsearch) and [`meteor show`](#meteorshow) commands.

You can add packages to your project with [`meteor add`](#meteoradd) and remove
them with [`meteor remove`](#meteorremove).
Additionally, [`meteor list`](#meteorlist) will tell you what
packages your project is using, and [`meteor update`](#meteorupdate)
will help keep them up to date.

By default all apps include the `standard-app-packages` package. This
automatically pulls in the packages that make up the core Meteor
stack. If you want to build your own custom stack, just remove
`standard-app-packages` from your app and add back in whichever of the standard
packages you want to keep.

Meteor uses a single-loading packaging system, meaning that it loads just one
version of every package. Before adding or upgrading to a particular version of
a package, Meteor uses a constraint solver to check if doing so will cause
other packages to break. By default, Meteor will choose conservatively. When
adding transitive dependencies (packages that other packages, but not the
application itself) depend on, Meteor will try to choose the earlier version.

In addition to the packages in the official Meteor release being used by your
app, `meteor list` and `meteor add` also search the `packages` directory at the
top of your app. You can also use the `packages` directory to break your app
into subpackages for your convenience, or to test packages that you might want
to publish. See [Writing Packages](#writingpackages).

{{/markdown}}
</template>


<template name="namespacing">
{{#markdown}}

  <h2 id="namespacing">Namespacing</h2>

Meteor's namespacing support makes it easy to write large applications
in JavaScript. Each package that you use in your app exists in its own
separate namespace, meaning that it sees only its own global variables
and any variables provided by the packages that it specifically
uses. Here's how it works.

When you declare a top-level variable, you have a choice. You can make
the variable File Scope or Package Scope.

    // File Scope. This variable will be visible only inside this
    // one file. Other files in this app or package won't see it.
    var alicePerson = {name: "alice"};

    // Package Scope. This variable is visible to every file inside
    // of this package or app. The difference is that 'var' is
    // omitted.
    bobPerson = {name: "bob"};

Notice that this is just the normal JavaScript syntax for declaring a
variable that is local or global. Meteor scans your source code for
global variable assignments and generates a wrapper that makes sure
that your globals don't escape their appropriate namespace.

In addition to File Scope and Package Scope, there are also
Exports. An export is a variable that a package makes available to you
when you use it. For example, the `email` package exports the `Email`
variable. If your app uses the `email` package (and _only_ if it uses
the `email` package!) then your app can see `Email` and you can call
`Email.send`. Most packages have only one export, but some packages
might have two or three (for example, a package that provides several
classes that work together).

You see only the exports of the packages that you use directly. If you
use package A, and package A uses package B, then you only see package
A's exports. Package B's exports don't "leak" into your namespace just
because you used package A. This keeps each namespace nice and
tidy. Each app or package only sees their own globals plus the APIs of
the packages that they specifically asked for.

When debugging your app, your browser's JavaScript console behaves as
if it were attached to your app's namespace. You see your app's
globals and the exports of the packages that your app uses
directly. You don't see the variables from inside those packages, and
you don't see the exports of your transitive dependencies (packages
that aren't used directly by your app, but that are used by packages
that are used by your app).

If you want to look inside packages from inside your in-browser
debugger, you've got two options:

* Set a breakpoint inside package code. While stopped on that
  breakpoint, the console will be in the package's namespace. You'll
  see the package's package-scope variables, imports, and also any
  file-scope variables for the file you're stopped in.

* If a package `foo` is included in your app, regardless of whether
  your app uses it directly, its exports are available in
  `Package.foo`. For example, if the `email` package is loaded, then
  you can access `Package.email.Email.send` even from namespaces that
  don't use the `email` package directly.

When declaring functions, keep in mind that `function x () {}` is just
shorthard for `var x = function () {}` in JavaScript. Consider these
examples:

    // This is the same as 'var x = function () ...'. So x() is
    // file-scope and can be called only from within this one file.
    function x () { ... }

    // No 'var', so x() is package-scope and can be called from
    // any file inside this app or package.
    x = function () { ... }

{{#note}}
Technically speaking, globals in an app (as opposed to in a package)
are actually true globals. They can't be captured in a scope that is
private to the app code, because that would mean that they wouldn't be
visible in the console during debugging! This means that app globals
actually end up being visible in packages. That should never be a
problem for properly written package code (since the app globals will
still be properly shadowed by declarations in the packages). You
certainly shouldn't depend on this quirk, and in the future Meteor may
check for it and throw an error if you do.
{{/note}}

{{/markdown}}
</template>


<template name="deploying">
{{#markdown}}

<h2 id="deploying">Deploying</h2>

Meteor is a full application server.  We include everything you need
to deploy your application on the internet: you just provide the JavaScript,
HTML, and CSS.

<h3 class="nosection">Running on Meteor's infrastructure</h3>

The easiest way to deploy your application is to use `meteor
deploy`.  We provide it because it's what, personally, we've always
wanted: an easy way to take an app idea, flesh it out over a weekend,
and put it out there for the world to use, with nothing getting in the
way of creativity.

    $ meteor deploy myapp.meteor.com

Your application is now available at myapp.meteor.com.  If
this is the first time deploying to this hostname, Meteor creates a
fresh empty database for your application.  If you want to deploy an
update, Meteor will preserve the existing data and just refresh the
code.

You can also deploy to your own domain.  Just set up the hostname you
want to use as a CNAME to `origin.meteor.com`, then deploy to that name.

    $ meteor deploy www.myapp.com

We provide this as a free service so you can try Meteor.  It is also
helpful for quickly putting up internal betas, demos, and so on. For
more information, see [meteor deploy](#meteordeploy).

<h3 class="nosection">Running on your own infrastructure</h3>

You can also run your application on your own infrastructure, or any
other hosting provider like Heroku.

To get started, run

    $ meteor bundle myapp.tgz

This command will generate a fully-contained Node.js application in the form of
a tarball.  To run this application, you need to provide Node.js 0.10 and a
MongoDB server.  (The current release of Meteor has been tested with Node
0.10.29; older versions contain a serious bug that can cause production servers
to stall.) You can then run the application by invoking node, specifying the
HTTP port for the application to listen on, and the MongoDB endpoint.  If
you don't already have a MongoDB server, we can recommend our friends at
[MongoHQ](http://mongohq.com).

    $ cd bundle
    $ (cd programs/server && npm install)
    $ PORT=3000 MONGO_URL=mongodb://localhost:27017/myapp node main.js

Other packages may require other environment variables (for example, the `email`
package requires a `MAIL_URL` environment variable).

{{/markdown}}
</template>


<template name="packages_writing">
{{#markdown}}

  <h2 id="writingpackages">Writing packages</h2>

Writing Meteor packages is easy. To initialize a meteor package, run
`meteor create --package username:packagename`, where `username` is your Meteor
Developer username. This will create a package from scratch and prefill the
directory with a package.js control file and some javascript. By default, Meteor
will take the package name from the name of the directory that contains the
package.js file.

Meteor promises repeatable builds for both packages and applications. This means
that, if you built your package on a machine, then checked the code into a
repository and checked it out elsewhere, you should get the same result. In your
package directory, you will find an automatically generated versions.json
file. This file specifies the versions of all packages used to build your
package and is part of the source. Check it into version control to ensure
repeatable builds across machines.

{{#note}}

Sometimes, packages do not just stand on their own, but function in the context
of an app (specifically, packages in the packages directory of an app). In that
case, the app's context will take precedence. Rather than using the
versions.json file as a guide, we will build the package with the same
dependencies as used by the app (we think that, in practice, it would be
confusing to find your local packages built with different versions of
things). However, we will still write the new versions.json file.

{{/note}}

You can read more about [`package.js`](#packagejs) files in the API
section.

A word on testing: since testing is an important part of the development process,
there are two common ways to test a package:

* Integration tests (putting a package directly into an application, and writing
tests against the application) is the most common way to test a package. After
creating your package, add it to your app's /packages directory and run `meteor
add`. This will add your package to your app as a local package. You can then
test and run your app as usual. Meteor will detect and respond to changes to
your local package, just as it does to your app files.

* Unit tests are run with the command [`meteor test-packages
package-name`](#meteortestpackages). As described in the [`package.js`](#packagejs)
section, you can use the `package.js` file to specify where your unit tests are
located. If you have a repository that contains only the package source, you can
test your package by specifying the path to the package directory (which must
contain a slash), such as `meteor test-packages ./`.

To publish a package, run [`meteor publish`](#meteorpublish) from the package
directory.  There are some extra restrictions on published packages: they must
contain a version (Meteor packages are versioned using
strict <a href="http://www.semver.org">semver</a> versioning) and their names
must be prefixed with the username of the author and a colon, like so:
`iron:router`. This namespacing allows for more descriptive and on-topic package
names.

{{/markdown}}
</template>
